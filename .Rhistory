as_mean_tobit(2, 1:2, "foo"),
regexp="'sd' must be a scalar"
)
test_that("as_mean_tobit", {
expect_equal(
as_mean_tobit(1, 2, "foo"),
structure(
1,
sd=2,
message="foo",
class="mean_tobit"
)
)
expect_error(
as_mean_tobit("A", 2, "foo"),
regexp="'mu' must be numeric"
)
expect_error(
as_mean_tobit(1:2, 2, "foo"),
regexp="'mu' must be a scalar"
)
expect_error(
as_mean_tobit(2, "A", "foo"),
regexp="'sd' must be numeric"
)
expect_error(
as_mean_tobit(2, 1:2, "foo"),
regexp="'sd' must be a scalar"
)
})
expect_equal(
as_geomean_tobit(1, 2, "foo"),
structure(
1,
sd=2,
message="foo",
class=c("geomean_tobit", "mean_tobit")
)
)
expect_error(
as_geomean_tobit(as_mean_tobit(1, 2, "foo")),
regexp="mean_tobit can only be converted to a geomean_tobit if it is NA"
)
expect_equal(
as_geomean_tobit(as_mean_tobit(NA, 2, "foo")),
as_geomean_tobit(NA, 2, "foo")
)
as_mean_tobit(NA_real_, NA_real_, "foo")
devtools::load_all()
expect_equal(
as_mean_tobit(NA, NA, "foo"),
as_mean_tobit(NA_real_, NA_real_, "foo")
)
expect_equal(
as_mean_tobit(NA, NA_character_, "foo"),
as_mean_tobit(NA_real_, NA_real_, "foo")
)
as_mean_tobit(2, NA, "foo")
expect_error(
as_mean_tobit(NA, 2, "foo"),
regexp="'mu' and 'sd' must either both or neither be NA"
)
expect_equal(
as_geomean_tobit(1, 2, "foo"),
structure(
1,
sd=2,
message="foo",
class=c("geomean_tobit", "mean_tobit")
)
)
expect_error(
as_geomean_tobit(as_mean_tobit(1, 2, "foo")),
regexp="mean_tobit can only be converted to a geomean_tobit if it is NA"
)
expect_equal(
as_geomean_tobit(as_mean_tobit(NA_real_, 2, "foo")),
as_geomean_tobit(NA_real_, 2, "foo")
)
expect_equal(
as_geomean_tobit(as_mean_tobit(NA_real_, NA, "foo")),
as_geomean_tobit(NA_real_, NA, "foo")
)
expect_equal(
expect_warning(
as_geomean_tobit(as_mean_tobit(NA, 2, "foo"), sd=1),
regexp="'sd' is ignored"
),
as_geomean_tobit(NA, 2, "foo")
)
expect_equal(
expect_warning(
as_geomean_tobit(as_mean_tobit(NA, NA, "foo"), sd=1),
regexp="'sd' is ignored"
),
as_geomean_tobit(NA, NA, "foo")
)
expect_equal(
expect_warning(
as_geomean_tobit(as_mean_tobit(NA, NA, "foo"), message="foo"),
regexp="'message' is ignored"
),
as_geomean_tobit(NA, NA, "foo")
)
as_mean_tobit(1, 2)
as_cv_tobit(as_mean_tobit(1, 2))
devtools::load_all()
as_cv_tobit(as_mean_tobit(1, 2))
#' @describeIn as_cv_tobit CV for the arithmetic mean: \code{100*sd/mu}
#' @export
as_cv_tobit.mean_tobit <- function(x) {
100*attr(x, "sd", exact=TRUE)/as.numeric(x)
}
rm(as_cv_tobit)
rm(as_cv_tobit.mean_tobit()
)
rm(as_cv_tobit.mean_tobit)
devtools::load_all()
expect_equal(
as_cv_tobit(as_mean_tobit(1, 2)),
200
)
as_cv_tobit(as_geomean_tobit(1, 2))
100*sqrt(exp(2^2)-1)
PKNCA::geocv
sd(log(c(2, 3)))
sd(log(1:2))
as_cv_tobit(as_geomean_tobit(1, sd(log(1:2))))
expect_equal(
as_cv_tobit(as_geomean_tobit(1, sd(log(1:2)))),
100*sqrt(exp(sd(log(1:2))^2)-1)
)
as_sd_tobit(1, 2, "foo")
expect_equal(
as_sd_tobit(1, 2, "foo"),
structure(
2,
mu=1,
message="foo",
class="sd_tobit"
)
)
as_tobit_input_check <- function(mu, sd, message) {
stopifnot("'mu' must be a scalar"=length(mu) == 1)
stopifnot("'sd' must be a scalar"=length(sd) == 1)
# Coerce NA to be numeric, regardless of the input class
if (is.na(mu)) {
mu <- NA_real_
}
if (is.na(sd)) {
sd <- NA_real_
}
stopifnot("'mu' must be numeric"=is.numeric(mu))
stopifnot("'sd' must be numeric"=is.numeric(sd))
stopifnot("'mu' and 'sd' must either both or neither be NA"=!xor(is.na(mu), is.na(sd)))
list(mu=mu, sd=sd)
}
devtools::load_all()
rm(as_tobit_input_check)
devtools::load_all()
expect_equal(
as_sd_tobit(1, 2, "foo"),
structure(
2,
mu=1,
message="foo",
class="sd_tobit"
)
)
expect_equal(
as_sd_tobit(mean_tobit(1, 2, "foo")),
structure(
2,
mu=1,
message="foo",
class=c("sd_tobit", "mean_tobit")
)
)
as_sd_tobit(mean_tobit(1, 2, "foo"))
as_sd_tobit(as_mean_tobit(1, 2, "foo"))
as_sd_tobit(as_mean_tobit(1, 2, "foo"))
as_sd_tobit(as_mean_tobit(1, 2, "foo"))
devtools::load_all()
as_sd_tobit(as_mean_tobit(1, 2, "foo"))
expect_equal(
as_sd_tobit(as_mean_tobit(1, 2, "foo")),
structure(
2,
mu=1,
message="foo",
class=c("sd_tobit", "mean_tobit")
)
)
as_sd_tobit(as_mean_tobit(1, 2, "foo"))
devtools::load_all()
as_sd_tobit(as_mean_tobit(1, 2, "foo"))
as_sd_tobit.default(
mu=as.numeric(mu),
sd=attr(mu, "sd", exact=TRUE),
message=attr(mu, "message", exact=TRUE)
)
structure(
as_sd_tobit.default(
mu=as.numeric(mu),
sd=attr(mu, "sd", exact=TRUE),
message=attr(mu, "message", exact=TRUE)
),
class=unique("sd_tobit", class(mu))
)
class(mu)
devtools::load_all()
as_sd_tobit(as_mean_tobit(1, 2, "foo"))
Q
devtools::load_all()
expect_equal(
as_sd_tobit(as_mean_tobit(1, 2, "foo")),
structure(
2,
mu=1,
message="foo",
class=c("sd_tobit", "mean_tobit")
)
)
as_geomean_tobit(1, 2, "foo")
expect_equal(
as_sd_tobit(as_geomean_tobit(1, 2, "foo")),
structure(
2,
mu=1,
message="foo",
class=c("sd_tobit", "geomean_tobit", "mean_tobit")
)
)
negLogLik_tobit(distribution="foo")
match.arg("foo", choices=c("t", "norm"))
try({match.arg("foo", choices=c("t", "norm"))})$message
try({match.arg("foo", choices=c("t", "norm"))})
foo <- try({match.arg("foo", choices=c("t", "norm"))})
foo <- try({match.arg("foo", choices=c("t", "norm"))})
foo
as.character(foo)
negLogLik_tobit(distribution="foo")
as.character(try({match.arg("foo", choices=c("t", "norm"))}, silent=TRUE))
gsub(x=as.character(try({match.arg("foo", choices=c("t", "norm"))}, silent=TRUE)), pattern="^.*?:", replacement="")
expect_error(
negLogLik_tobit(distribution="foo"),
regexp=
gsub(x=as.character(try({match.arg("foo", choices=c("t", "norm"))}, silent=TRUE)), pattern="^.*?:\s", replacement="")
)
expect_error(
negLogLik_tobit(distribution="foo"),
regexp=
gsub(x=as.character(try({match.arg("foo", choices=c("t", "norm"))}, silent=TRUE)), pattern="^.*?:\\s", replacement="")
)
expect_error(
negLogLik_tobit(distribution="foo"),
regexp=
gsub(x=as.character(try({match.arg("foo", choices=c("t", "norm"))}, silent=TRUE)), pattern="^.*?:\\s", replacement="")
)
gsub(x=as.character(try({match.arg("foo", choices=c("t", "norm"))}, silent=TRUE)), pattern="^.*?:\\s", replacement="")
gsub(x=as.character(try({match.arg("foo", choices=c("t", "norm"))}, silent=TRUE)), pattern="^.*?:\\S", replacement="")
?regexp
gsub(x=as.character(try({match.arg("foo", choices=c("t", "norm"))}, silent=TRUE)), pattern="^.*?:[:space:]*", replacement="")
gsub(x=as.character(try({match.arg("foo", choices=c("t", "norm"))}, silent=TRUE)), pattern="^.*?:[ \n]*", replacement="")
gsub(x=as.character(try({match.arg("foo", choices=c("t", "norm"))}, silent=TRUE)), pattern="^.*?:[ \n\t]*", replacement="")
expect_error(
negLogLik_tobit(distribution="foo")
)
expect_error(
negLogLik_tobit(mask_lower=c(FALSE, TRUE), mask_between=c(FALSE, TRUE), mask_upper=c(FALSE, TRUE)),
regexp="All values must be caught by mask_upper, mask_between, or mask_upper"
)
devtools::load_all()
expect_error(
negLogLik_tobit(mask_lower=c(FALSE, TRUE), mask_between=c(FALSE, TRUE), mask_upper=c(FALSE, TRUE)),
regexp="All values must be caught by mask_upper, mask_between, or mask_upper"
)
negLogLik_tobit(mask_lower=c(TRUE, TRUE), mask_between=c(FALSE, TRUE), mask_upper=c(FALSE, TRUE))
traceback()
negLogLik_tobit(x=1:2, mask_lower=c(TRUE, TRUE), mask_between=c(FALSE, TRUE), mask_upper=c(FALSE, TRUE))
devtools::load_all()
expect_error(
negLogLik_tobit(x=1:2, mask_lower=c(TRUE, TRUE), mask_between=c(FALSE, TRUE), mask_upper=c(FALSE, TRUE)),
regexp="mask_upper, mask_between, and mask_upper may not overlap"
)
negLogLik_tobit(
param=c(1, log(2)),
x=1:2,
mask_lower=c(TRUE, TRUE),
mask_between=c(FALSE, TRUE),
mask_upper=c(FALSE, TRUE)
)
negLogLik_tobit(
param=c(1, log(2), 1),
x=1:3,
mask_lower=c(TRUE, FALSE, FALSE),
mask_between=c(FALSE, TRUE, FALSE),
mask_upper=c(FALSE, FALSE, TRUE)
)
devtools::load_all()
negLogLik_tobit(
param=c(1, log(2), 1),
x=1:3,
mask_lower=c(TRUE, FALSE, FALSE),
mask_between=c(FALSE, TRUE, FALSE),
mask_upper=c(FALSE, FALSE, TRUE)
)
?dt
?dnorm
devtools::load_all()
devtools::load_all()
expect_error(
negLogLik_tobit(
param=c(1, log(2), 1),
x=1:3,
mask_lower=c(TRUE, FALSE, FALSE),
mask_between=c(FALSE, TRUE, FALSE),
mask_upper=c(FALSE, FALSE, TRUE)
),
regexp="param must have exactly 2 values"
)
negLogLik_tobit(
param=c(1, log(2)),
x=1:3,
mask_lower=c(TRUE, FALSE, FALSE),
mask_between=c(FALSE, TRUE, FALSE),
mask_upper=c(FALSE, FALSE, TRUE)
)
negLogLik_tobit(
param=c(1, log(2)),
x=1:3,
mask_lower=c(TRUE, FALSE, FALSE),
mask_between=c(FALSE, TRUE, FALSE),
mask_upper=c(FALSE, FALSE, TRUE),
lower_limit=1.5, upper_limit=4
)
pt(1:5, df = 1)
devtools::load_all()
negLogLik_tobit(
param=c(1, log(2)),
x=1:3,
mask_lower=c(TRUE, FALSE, FALSE),
mask_between=c(FALSE, TRUE, FALSE),
mask_upper=c(FALSE, FALSE, TRUE),
lower_limit=1.5, upper_limit=4
)
dnorm((x[mask_between] - mu)/sigma, log=TRUE)
pnorm((lower_limit[mask_lower] - mu)/sigma, log.p=TRUE)
pnorm((mu - upper_limit[mask_upper])/sigma, log.p=TRUE)
upper_limit[mask_upper]
mask_upper
upper_limit
negLogLik_tobit(distribution="foo")
expect_error(
negLogLik_tobit(distribution="foo")
)
expect_error(
negLogLik_tobit(mask_lower=c(FALSE, TRUE), mask_between=c(FALSE, TRUE), mask_upper=c(FALSE, TRUE)),
regexp="All values must be caught by mask_upper, mask_between, or mask_upper"
)
expect_error(
negLogLik_tobit(x=1:2, mask_lower=c(TRUE, TRUE), mask_between=c(FALSE, TRUE), mask_upper=c(FALSE, TRUE)),
regexp="mask_upper, mask_between, and mask_upper may not overlap"
)
expect_error(
negLogLik_tobit(
param=c(1, log(2), 1),
x=1:3,
mask_lower=c(TRUE, FALSE, FALSE),
mask_between=c(FALSE, TRUE, FALSE),
mask_upper=c(FALSE, FALSE, TRUE)
),
regexp="param must have exactly 2 values"
)
devtools::load_all()
expect_error(
negLogLik_tobit(distribution="foo")
)
expect_error(
negLogLik_tobit(mask_lower=c(FALSE, TRUE), mask_between=c(FALSE, TRUE), mask_upper=c(FALSE, TRUE)),
regexp="All values must be caught by mask_upper, mask_between, or mask_upper"
)
expect_error(
negLogLik_tobit(x=1:2, mask_lower=c(FALSE, TRUE), mask_between=c(FALSE, TRUE), mask_upper=c(FALSE, TRUE)),
regexp="All values must be caught by mask_upper, mask_between, or mask_upper"
)
negLogLik_tobit(x=1:2, lower_limit=1:2)
expect_error(
negLogLik_tobit(x=1:2, lower_limit=1:3)
)
negLogLik_tobit(x=1:2, lower_limit=1:3)
expect_error(
negLogLik_tobit(x=1:2, lower_limit=1:3),
regexp="length(x) == length(lower_limit) is not TRUE"
)
expect_error(
negLogLik_tobit(x=1:2, lower_limit=1:3),
regexp="length(x) == length(lower_limit) is not TRUE"
)
expect_error(
negLogLik_tobit(x=1:2, lower_limit=1:3),
regexp="length(x) == length(lower_limit) is not TRUE",
fixed=TRUE
)
expect_error(
negLogLik_tobit(x=1:2, lower_limit=1:2),
regexp="length(x) == length(lower_limit) is not TRUE",
fixed=TRUE
)
expect_error(
negLogLik_tobit(x=1:2, lower_limit=1:2, upper_limit=3:5),
regexp="length(x) == length(upper_limit) is not TRUE",
fixed=TRUE
)
expect_error(
negLogLik_tobit(x=1:2, lower_limit=1:2, upper_limit=3:5),
regexp="length(x) == length(upper_limit) is not TRUE",
fixed=TRUE
)
negLogLik_tobit(x=1:2, lower_limit=1:2, upper_limit=3:4, mask_lower=c(TRUE, FALSE, FALSE))
expect_error(
negLogLik_tobit(x=1:2, lower_limit=1:2, upper_limit=3:4, mask_lower=c(TRUE, FALSE), mask_between=c(FALSE, FALSE)),
regexp="length(x) == length(mask_lower) is not TRUE",
fixed=TRUE
)
expect_error(
negLogLik_tobit(x=1:2, lower_limit=1:2, upper_limit=3:4, mask_lower=c(TRUE, FALSE), mask_between=c(FALSE, FALSE, FALSE)),
regexp="length(x) == length(mask_between) is not TRUE",
fixed=TRUE
)
expect_error(
negLogLik_tobit(x=1:2, lower_limit=1:2, upper_limit=3:4, mask_lower=c(TRUE, FALSE), mask_between=c(FALSE, FALSE), mask_upper=c(FALSE, FALSE, FALSE)),
regexp="length(x) == length(mask_upper) is not TRUE",
fixed=TRUE
)
expect_error(
negLogLik_tobit(x=1:2, mask_lower=c(FALSE, TRUE), mask_between=c(FALSE, TRUE), mask_upper=c(FALSE, TRUE)),
regexp="All values must be caught by mask_upper, mask_between, or mask_upper"
)
expect_error(
negLogLik_tobit(
x=1:2, lower_limit=1:2, upper_limit=3:4,
mask_lower=c(FALSE, TRUE), mask_between=c(FALSE, TRUE), mask_upper=c(FALSE, TRUE)
),
regexp="All values must be caught by mask_upper, mask_between, or mask_upper"
)
expect_error(
negLogLik_tobit(
x=1:2, lower_limit=1:2, upper_limit=3:4,
mask_lower=c(FALSE, TRUE), mask_between=c(FALSE, TRUE), mask_upper=c(FALSE, TRUE)
),
regexp="All values must be caught by mask_upper, mask_between, or mask_upper"
)
expect_error(
negLogLik_tobit(
x=1:2, lower_limit=1:2, upper_limit=3:4,
mask_lower=c(TRUE, TRUE), mask_between=c(FALSE, TRUE), mask_upper=c(FALSE, TRUE)
),
regexp="mask_upper, mask_between, and mask_upper may not overlap"
)
expect_error(
negLogLik_tobit(
param=c(1, log(2), 1),
x=1:3,
mask_lower=c(TRUE, FALSE, FALSE),
mask_between=c(FALSE, TRUE, FALSE),
mask_upper=c(FALSE, FALSE, TRUE)
),
regexp="param must have exactly 2 values"
)
expect_error(
negLogLik_tobit(
param=c(1, log(2), 1),
x=1:3,
lower_limit=rep(1.5, 3), upper_limit=rep(4, 3),
mask_lower=c(TRUE, FALSE, FALSE),
mask_between=c(FALSE, TRUE, FALSE),
mask_upper=c(FALSE, FALSE, TRUE)
),
regexp="param must have exactly 2 values"
)
negLogLik_tobit(
param=c(1, log(2)),
x=1:3,
lower_limit=rep(1.5, 3), upper_limit=rep(4, 3),
mask_lower=c(TRUE, FALSE, FALSE),
mask_between=c(FALSE, TRUE, FALSE),
mask_upper=c(FALSE, FALSE, TRUE)
)
sum(
c(
dt((2 - 1)/2, df=l_x, log=TRUE),
pt((1.5 - 1)/2, df=l_x, log.p=TRUE),
pt((1 - 4)/2, df=l_x, log.p=TRUE)
)
)
sum(
c(
dt((2 - 1)/2, df=3, log=TRUE),
pt((1.5 - 1)/2, df=3, log.p=TRUE),
pt((1 - 4)/2, df=3, log.p=TRUE)
)
)
mean_tobit(1:5, lower=1, upper=4, include_equal=TRUE, distribution="t")
?optim
mean_tobit(1:5, lower=1, upper=4, include_equal=TRUE, distribution="t", control=list(trace=2))
mean_tobit(1:5, lower=1, upper=4, include_equal=TRUE, distribution="t", control=list(trace=2, maxit=200))
mean_tobit(1:10, lower=1, upper=4, include_equal=TRUE, distribution="t", control=list(trace=2, maxit=200))
mean_tobit(1:10, lower=1, upper=6, include_equal=TRUE, distribution="t", control=list(trace=2, maxit=200))
mean_tobit(1:10, lower=1, upper=6, include_equal=TRUE, distribution="t")
mean_tobit(1:10, lower=1, upper=6, include_equal=TRUE, distribution="norm")
?pnorm
